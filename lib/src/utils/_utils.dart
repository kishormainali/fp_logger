import 'dart:convert';
import 'dart:math';

/// Matches a stacktrace line as generated on Android/iOS devices.
///
final _deviceStackTraceRegex = RegExp(r'#[0-9]+\s+(.+) \((\S+)\)');

/// Matches a stacktrace line as generated by Flutter web.
///
final _webStackTraceRegex = RegExp(r'^((packages|dart-sdk)/\S+/)');

/// Matches a stacktrace line as generated by browser Dart.
///
/// For example:
/// * dart:sdk_internal
final _browserStackTraceRegex = RegExp(r'^(?:package:)?(dart:\S+|\S+)');

/// line width of the logger
int get _lineWidth => 90;

/// top line of the logger
String get topLine => '┌${'─' * _lineWidth}';

/// middle line of the logger
String get divider => '├${'─' * _lineWidth}';

/// left line of the logger
String get leftLine => '│ ';

/// bottom line of the logger
String get bottomLine => '└${'─' * _lineWidth}';

/// formats the stacktrace
List<String>? formatStackTrace(StackTrace? stackTrace) {
  if (stackTrace == null) return null;
  final lines = stackTrace.toString().split('\n').where(
    (element) {
      return !_discardDeviceStacktraceLine(element) &&
          !_discardWebStacktraceLine(element) &&
          !_discardBrowserStacktraceLine(element) &&
          element.isNotEmpty;
    },
  ).toList();
  final formatted = <String>[];
  final methodCount = min(lines.length, 8);
  for (var count = 0; count < methodCount; count++) {
    final line = lines[count];
    if (count < 0) {
      continue;
    }
    formatted.add('#$count   ${line.replaceFirst(RegExp(r'#\d+\s+'), '')}');
  }

  if (formatted.isEmpty) {
    return null;
  } else {
    return formatted;
  }
}

/// Discards stacktrace lines that are not useful.
bool _discardDeviceStacktraceLine(String line) {
  final match = _deviceStackTraceRegex.matchAsPrefix(line);
  if (match == null) {
    return false;
  }
  final segment = match.group(2)!;
  return segment.startsWith('package:fp_logger');
}

/// Discards stacktrace lines that are not useful.
bool _discardWebStacktraceLine(String line) {
  final match = _webStackTraceRegex.matchAsPrefix(line);
  if (match == null) {
    return false;
  }
  final segment = match.group(1)!;
  return segment.startsWith('packages/fp_logger') ||
      segment.startsWith('dart-sdk/lib');
}

/// Discards stacktrace lines that are not useful.
bool _discardBrowserStacktraceLine(String line) {
  final match = _browserStackTraceRegex.matchAsPrefix(line);
  if (match == null) {
    return false;
  }
  final segment = match.group(1)!;
  return segment.startsWith('package:fp_logger') || segment.startsWith('dart:');
}

/// convert dynamic message into list of messages
List<String> stringifyMessage(dynamic message) {
  var finalMessage = message is Function ? message() : message;

  /// try to decode if string
  if (finalMessage is String) finalMessage = decode(finalMessage);

  if (finalMessage == null) return [];

  if (finalMessage is Iterable<String>) {
    finalMessage = finalMessage.map(decode).toList();
  }

  if (finalMessage is Map || finalMessage is Iterable) {
    try {
      final encoder =
          JsonEncoder.withIndent('  ', (object) => object.toString());
      finalMessage = encoder.convert(finalMessage);
    } catch (_) {
      finalMessage = finalMessage.toString();
    }
  }

  final lines = finalMessage.toString().split('\n');
  if (lines.any((element) => element.length > _lineWidth)) {
    return lines.map(splitLine).expand((element) => element).toList();
  } else {
    return lines;
  }
}

Iterable<String> splitLine(String rest) {
  if (rest.split(' ').length > 1) {
    return _splitByWord(rest);
  } else {
    return _splitLineByWidth(rest);
  }
}

Iterable<String> _splitByWord(String rest) {
  final words = rest.split(' ');
  final lines = <String>[];
  var tempLine = '';
  for (final word in words) {
    if ('$tempLine $word'.length > _lineWidth) {
      lines.add(tempLine);
      tempLine = word;
    } else {
      tempLine += ' $word';
    }
  }
  lines.add(tempLine);
  return lines.map((line) => line.trim());
}

Iterable<String> _splitLineByWidth(String rest) {
  final lines = <String>[];
  for (var i = 0; i < rest.length; i += _lineWidth) {
    try {
      lines.add(rest.substring(i, i + _lineWidth));
    } catch (_) {
      lines.add(rest.substring(i));
    }
  }
  return lines.map((line) => line.trim());
}

/// decodes the message
dynamic decode(dynamic message) {
  try {
    return json.decode(message);
  } catch (_) {
    return message;
  }
}

String? parseOperationNameFromRequest(Map<String, dynamic> data) {
  final operationName = data['operationName'];
  if (operationName is String && operationName.isNotEmpty) {
    return operationName;
  }
  return null;
}
